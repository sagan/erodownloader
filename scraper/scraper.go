package scraper

import (
	"bytes"
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"slices"
	"strings"

	"github.com/natefinch/atomic"
	log "github.com/sirupsen/logrus"
	"gopkg.in/yaml.v3"

	"github.com/sagan/erodownloader/constants"
	"github.com/sagan/erodownloader/util"
	"github.com/sagan/erodownloader/util/stringutil"
)

const METAFILE = "metadata.nfo"
const COVER = "cover"

const TAG_R18 = "18禁"
const TAG_VOICEASMR = "ボイス・ASMR"

// Stored in metadata.nfo header using YAML front matter.
// See. https://jekyllrb.com/docs/front-matter/ .
// Title is a must field, all other fields are optional.
// All array type meta must be comprised of non-empty unique items,
// Tags should be sorted in lexical order.
// For now, write all array type meta to metadata.nfo as csv style string, instead of strict yaml array,
// this is for compatibility with other programs.
type Metadata struct {
	Title                  string   `yaml:"title,omitempty" json:"title,omitempty"`
	Author                 string   `yaml:"author,omitempty" json:"author,omitempty"`
	Series                 string   `yaml:"series name,omitempty" json:"series,omitempty"`
	YamlNarrator           string   `yaml:"narrator,omitempty" json:"yaml_narrator,omitempty"`
	YamlTags               string   `yaml:"tags,omitempty" json:"yaml_tags,omitempty"`
	Number                 string   `yaml:"number,omitempty" json:"number,omitempty"`
	YamlOtherEditionNumber string   `yaml:"other edition number,omitempty"`
	Date                   string   `yaml:"date,omitempty" json:"date,omitempty"`
	Source                 string   `yaml:"source,omitempty" json:"source,omitempty"`
	GeneratedBy            string   `yaml:"generated by,omitempty" json:"generated_by,omitempty"`
	Narrator               []string `yaml:"-" json:"narrator,omitempty"`
	Tags                   []string `yaml:"-" json:"tags,omitempty"`
	OtherEditionNumber     []string `yaml:"-" json:"other_edition_number,omitempty"`
	Text                   string   `yaml:"-" json:"text,omitempty"`               // full text. Must not has leading or trailing whitespaces.
	Files                  []string `yaml:"-" json:"files,omitempty"`              // additional meta files saved in tmpdir.
	CanonicalFilename      string   `yaml:"-" json:"canonical_filename,omitempty"` // If empty, fallback to use metadata.GetCanonicalName()
	ShouldRename           bool     `yaml:"-" json:"should_rename,omitempty"`      // Indicate the content-dir should be renamed to canonical filename
}

type Scraper struct {
	Name    string
	Version string
	Pre     func(filename string) bool
	Do      func(filename string, tmpdir string) (*Metadata, error)
}

type Scrapes []*Scraper

// Capture "[number][author]title" subgroups
var canonicalFilenameRegexp = regexp.MustCompile(`^\[(?P<number>.+?)\]\[(?P<author>.+?)\](?P<title>.+)$`)

// Match "【...】" and some "《...》", "[...]", "(...)" parts which contains non-sense infomations
// that should be removed from filenames. E.g.: "《期間限定110円》", "【KU100】" .
var nonSenseRegex = func() *regexp.Regexp {
	patterns := []string{
		`(期間限定)?\s*\d+\s*円`,
		`KU100\s*(使用)?`,
	}
	pattern := "("
	for i, ptn := range patterns {
		if i > 0 {
			pattern += "|"
		}
		pattern += ptn
	}
	pattern += ")"

	bracelets := [][2]string{
		{`(`, `)`},
		{`（`, `）`},
		{`[`, `]`},
		{`《`, `》`},
	}
	bracePatterns := `((【(.*?)】)`
	for _, bracelet := range bracelets {
		bracePatterns += fmt.Sprintf("|(%s%s%s)", regexp.QuoteMeta(bracelet[0]), pattern, regexp.QuoteMeta(bracelet[1]))
	}
	bracePatterns += `)`
	allPatterns := fmt.Sprintf(`(?i)(^%s)|(%s$)`, bracePatterns, bracePatterns)
	return regexp.MustCompile(allPatterns)
}()

var (
	ErrInvalid  = fmt.Errorf("invalid metadada file")
	ErrExists   = fmt.Errorf("metadata file already exists")
	ErrNotFound = fmt.Errorf("work info not found in site, it may be deleted")
	ErrNoNumber = fmt.Errorf("no number can be found")
	allScrapers = map[string]*Scraper{}
)

// Remove non sense parts from title.
// Non-sense parts include some "【...】", "《...》", "[...]", "(...)" parts with certain texts inside.
// E.g.: "【KU100】",  "《期間限定110円》" .
func removeNonSenseFromTitle(title string) string {
	for {
		str := nonSenseRegex.ReplaceAllString(title, "")
		if str == "" || str == title {
			break
		}
		title = str
	}
	return title
}

// Return canonical filename of the resource.
// The default name is "[number][author]title", title is truncated if it's too long.
func (m *Metadata) GetCanonicalFilename() (filename string) {
	if m.CanonicalFilename != "" {
		return m.CanonicalFilename
	}
	number := util.CleanBasenameComponent(m.Number)
	author := util.CleanBasenameComponent(m.Author)
	title := util.CleanBasenameComponent(m.Title)
	if number != "" {
		filename += fmt.Sprintf("[%s]", number)
	}
	if author != "" {
		filename += fmt.Sprintf("[%s]", author)
	}
	filename += title
	return util.CleanBasename(filename)
}

func Register(scraper *Scraper) {
	allScrapers[scraper.Name] = scraper
}

func NewScrapers(names ...string) (Scrapes, error) {
	var scrapers []*Scraper
	if len(names) == 0 {
		return nil, fmt.Errorf("no name provided")
	}
	for _, name := range names {
		if allScrapers[name] == nil {
			return nil, fmt.Errorf("scraper %q does not exist", name)
		}
		scrapers = append(scrapers, allScrapers[name])
	}
	return scrapers, nil
}

func (s Scrapes) Scrape(dirname string, tmpdir string, force bool) (*Metadata, error) {
	metafile := filepath.Join(dirname, METAFILE)
	basename := filepath.Base(dirname)
	if !force && util.FileExists(metafile) {
		return nil, ErrExists
	}
	triedScrapers := []string{}
	for _, scraper := range s {
		if !scraper.Pre(dirname) {
			continue
		}
		log.Printf("Scrape %s using %s scraper", dirname, scraper.Name)
		tmp := filepath.Join(tmpdir, basename)
		if err := util.MakeCleanTmpDir(tmp); err != nil {
			return nil, fmt.Errorf("failed to make tmp dir %q: %v", tmp, err)
		}
		triedScrapers = append(triedScrapers, scraper.Name)
		metadata, err := scraper.Do(dirname, tmp)
		if err != nil {
			if errors.Is(err, ErrNotFound) {
				continue
			}
			return nil, err
		}
		if metadata == nil {
			return nil, ErrInvalid
		}
		metadata.Title = stringutil.CleanTitle(metadata.Title)
		if metadata.Title == "" {
			return nil, ErrInvalid
		}
		metadata.Author = stringutil.CleanTitle(metadata.Author)
		metadata.Series = stringutil.CleanTitle(metadata.Series)
		metadata.Number = stringutil.CleanTitle(metadata.Number)
		metadata.Date = stringutil.CleanTitle(metadata.Date)
		metadata.Source = stringutil.CleanTitle(metadata.Source)
		metadata.GeneratedBy = stringutil.CleanTitle(metadata.GeneratedBy)
		metadata.Tags = util.UniqueSlice(util.OmitemptySlice(metadata.Tags))
		metadata.Narrator = util.UniqueSlice(util.OmitemptySlice(metadata.Narrator))
		metadata.OtherEditionNumber = util.UniqueSlice(util.OmitemptySlice(metadata.OtherEditionNumber))
		slices.Sort(metadata.Tags)

		metadata.GeneratedBy = constants.NAME + "-" + scraper.Name + "-v" + scraper.Version
		for _, file := range metadata.Files {
			srcpath := filepath.Join(tmp, file)
			targetpath := filepath.Join(dirname, file)
			if util.FileExists(targetpath) {
				log.Tracef("meta file %q exists, skip it", targetpath)
				continue
			}
			if err := atomic.ReplaceFile(srcpath, targetpath); err != nil {
				return nil, fmt.Errorf("failed to write to %q", targetpath)
			}
		}
		tmpMetafile := filepath.Join(tmp, METAFILE)
		if err := WriteMetadata(tmpMetafile, metadata); err != nil {
			return nil, fmt.Errorf("failed to write metafile: %w", err)
		}
		if err := atomic.ReplaceFile(tmpMetafile, filepath.Join(dirname, METAFILE)); err != nil {
			return nil, fmt.Errorf("failed to save metafile: %w", err)
		}
		os.RemoveAll(tmp)
		return metadata, nil
	}
	if len(triedScrapers) > 0 {
		return nil, fmt.Errorf("no metadata found for %q (tried scrapers: %v)", dirname, triedScrapers)
	}
	return nil, fmt.Errorf("no suitable scraper found for %q", dirname)
}

func WriteMetadata(metafile string, metadata *Metadata) error {
	metadata.YamlNarrator = strings.Join(metadata.Narrator, ", ")
	metadata.YamlTags = strings.Join(metadata.Tags, ", ")
	metadata.YamlOtherEditionNumber = strings.Join(metadata.OtherEditionNumber, ", ")
	metaHeader, err := yaml.Marshal(metadata)
	if err != nil {
		return err
	}
	data := ""
	data += "---\n"
	data += string(metaHeader)
	data += "---\n"

	if metadata.Text != "" {
		data += "\n" + metadata.Text + "\n"
	}
	return os.WriteFile(metafile, []byte(data), 0600)
}

func ReadMetadata(metafile string) (metadata *Metadata, err error) {
	contents, err := os.ReadFile(metafile)
	if err != nil {
		return nil, err
	}
	deli := []byte("---\n")
	// The "title" is a MUST field. As such, the calculated min valid length is 15.
	if len(contents) < 15 || !bytes.Equal(contents[:len(deli)], deli) {
		return nil, ErrInvalid
	}
	contents = contents[len(deli):]
	index := bytes.Index(contents, deli)
	if index < 7 {
		return nil, ErrInvalid
	}
	text := strings.TrimSpace(string(contents[index+len(deli):]))
	contents = contents[:index]
	if err = yaml.Unmarshal(contents, &metadata); err != nil {
		return nil, err
	}
	if metadata.Title == "" {
		return nil, err
	}
	metadata.Narrator = util.SplitCsv(metadata.YamlNarrator)
	metadata.Tags = util.SplitCsv(metadata.YamlTags)
	metadata.OtherEditionNumber = util.SplitCsv(metadata.YamlOtherEditionNumber)
	metadata.Text = text
	return metadata, nil
}

// regexp: must has a "number" sub group.
func GetNumberFromFilename(regexp *regexp.Regexp, filename string) string {
	matches := regexp.FindStringSubmatch(filename)
	if matches != nil {
		return matches[regexp.SubexpIndex("number")]
	}
	return ""
}

// Get standard name
func GetRename(originalname string, metadata *Metadata) (canonicalName string, shouldRename bool) {
	if substrings := canonicalFilenameRegexp.FindStringSubmatch(originalname); substrings == nil {
		metadataClone := *metadata
		metadataClone.CanonicalFilename = ""
		metadataClone.Title = removeNonSenseFromTitle(metadataClone.Title)
		return metadataClone.GetCanonicalFilename(), true
	} else {
		title := removeNonSenseFromTitle(substrings[canonicalFilenameRegexp.SubexpIndex("title")])
		if title != substrings[canonicalFilenameRegexp.SubexpIndex("title")] {
			metadata := &Metadata{}
			metadata.Author = substrings[canonicalFilenameRegexp.SubexpIndex("author")]
			metadata.Number = substrings[canonicalFilenameRegexp.SubexpIndex("number")]
			metadata.Title = title
			return metadata.GetCanonicalFilename(), true
		} else if normalizedName := util.CleanBasename(originalname); normalizedName != originalname {
			return normalizedName, true
		}
	}
	return "", false
}
